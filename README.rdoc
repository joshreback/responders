# Writing DRY Controllers with Responders

### Understanding Responders

- There are 3 variables that affect how controllers respond:

1. Request Type - Navigational (HTML) or API (JSON)
2. HTTP Verb - GET, DELETE, POST, PUT
3. Resource Status - The result of the operation

**Default Behavior** (i.e, as generated by a scaffold)

        | Navigational Request   | API Request                                  | Status
--------|------------------------|------------------------------------------------------
GET     | render template        | render template or render resource.to_format |
POST    | redirect_to resource   | render template or resource.to_format        | SUCCESS
POST    | redirect_to resource   | render resource.errors                       | FAILURE
PUT     | render :new            | head :no_content                             | SUCCESS
PUT     | render :edit           | render resource.errors                       | FAILURE
DELETE  | redirect_to collection | head :no_content                             | SUCCESS
DELETE  | redirect_to collection | render resource.errors                       | FAILURE


### Exploring ActionController::Responder

- Anything that responds to `call()` and accepts 3 arguments can be a responder
- The three arguments are: the current controller, the resource (or array of resources), and a hash of options
- Inside `ActionController::Responder` the responder tries to invoke the `default_render` method before falling back to the
  API or Navigational behavior (default case depending on request type)

_Code path for Navigation Requests_
- For a GET request, it raises a missing-template error
- For other HTTP verbs, it redirects to the resource if there are no errors
- If there are errors, it renders a default action

_Code path for API Requests_
- It merges the options given to repond_with and adds a format
- Important to note that responders do not call `resource.to_<format>`
  - That behavior is delegated to the render method

- We can also customize responders by passing a block (in the `respond_to` style)
- We can change how all controllers respond by setting the responder (either at the application level or the controller level)

### Creating our own responder

- Goal: Create a way to change default flash messages
  - Will use the i18n framework to set flash messages in YAML files, configure default values, and make it possible to translate such messages in the future.

### HTTP Cache Responder

Caching mechanism works as folllows:
- Server returns a Last-Modified header to the response
- Client adds an If-Modified-Since header with timestamp equal to the Last-Modified header
- When server processes the subsequent request, if the resource has not changed it returns `304 Not Modified`



















